def lengthOfLongestSubstring(s: str) -> int:
    start = 0
    end = 0
    max_length = 0
    characters = set()
    
    while end < len(s):
        if s[end] not in characters:
            characters.add(s[end])  # Добавляем символ s[end] в множество characters
            end += 1  # Увеличиваем индекс окончания end на 1
            max_length = max(max_length, end - start)  # Обновляем max_length с учетом текущей длины подстроки
        else:
            characters.remove(s[start])  # Удаляем символ s[start] из множества characters
            start += 1  # Увеличиваем индекс начала start на 1, сдвигая окно
    return max_length  # Возвращаем длину самой длинной подстроки без повторяющихся символов
  
  
# В этом коде:

# start и end представляют индексы начала и конца окна соответственно.
# max_length инициализируется нулем и будет хранить максимальную длину подстроки без повторяющихся символов.
# characters - это множество, в котором будут храниться уникальные символы текущего окна.
# Алгоритм:

# Инициализация переменных start, end, max_length и characters.
# Входим в цикл while, который будет выполняться, пока end находится в пределах строки s.
# Проверяем, есть ли символ s[end] в множестве characters (проверка на уникальность).
# Если символ отсутствует в множестве, добавляем его в множество, увеличиваем end на 1 и обновляем max_length с учетом текущей длины подстроки.
# Если символ уже присутствует в множестве, выполняем следующие действия для сдвига окна.
# Удаляем символ s[start] из множества characters и увеличиваем start на 1 для сдвига начала окна.
# Повторяем шаги 3-4 до окончания цикла.
# Возвращаем max_length, представляющую длину самой длинной подстроки без повторяющихся символов.
# Алгоритм с использованием алгоритма сдвигающегося окна позволяет эффективно находить длину самой длинной подстроки без повторяющихся символов в строке s.
